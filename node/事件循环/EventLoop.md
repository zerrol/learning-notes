### Event Loop

node 采用阻塞的`I/O模型`。当触发需要异步执行的事件时，例如操作系统的文件操作，node会将这个事件的回调放入事件循环队列中，等待这个事件执行结束后，再等待**执行时机**。

#### 执行机制

当node在启动时，便会初始化`Event Loop`。

事件循环`Event loop`有多个阶段，每个阶段都有一个`FIFO队列`。**这里便与浏览器的Event Loop有一些区别。**

node 会在每个阶段的队列清空，或者达到这个阶段的**最大执行限制**时，进入到下一个阶段的执行队列中。

#### 执行阶段

```
   ┌───────────────────────────┐
┌─>│           timers          │    // 定时器
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │     pending callbacks     │    // 待定回调
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │       idle, prepare       │    // node内部使用
│  └─────────────┬─────────────┘      ┌───────────────┐
│  ┌─────────────┴─────────────┐      │   incoming:   │
│  │           poll            │<─────┤  connections, │  // 最重要的阶段：轮询
│  └─────────────┬─────────────┘      │   data, etc.  │
│  ┌─────────────┴─────────────┐      └───────────────┘
│  │           check           │    // 检测
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
└──┤      close callbacks      │    // 关闭回调函数
   └───────────────────────────┘

   每个框为事件循环机制的一个阶段

```

`timers`定时器：本阶段执行已经被 setTimeout() 和 setInterval() 的调度回调函数。

`pending callbacks`待定回调：执行延迟到下一个循环迭代的 I/O 回调。

`idle, prepare`：仅系统内部使用。

`poll`轮询：检索新的 I/O 事件;执行与 I/O 相关的回调（除了关闭的回调函数，那些由计时器和 setImmediate() 调度的之外, 几乎所有的回调），其余情况 node 将在适当的时候在此阻塞。

`check`检测：setImmediate() 回调函数在这里执行。

`close callbacks`关闭的回调函数：一些关闭的回调函数，如：socket.on('close', ...)。

在每次事件循环的运行之间，Node.js 都会检查事件循环是否还有等待执行的异常I/O或者计时器。如果没有的话，就会关闭掉它。

> Between each run of the event loop, Node.js checks if it is waiting for any asynchronous I/O or timers and shuts down cleanly if there are not any.

#### timer 定时器阶段
